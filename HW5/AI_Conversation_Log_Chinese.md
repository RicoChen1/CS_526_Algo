# 二叉搜索树(BST)实现与演示——思路与注意事项

## 目标
- 定义 `Node` 与 `BST` 两个抽象数据类型(ADT)
- 提供方法：`add_node(value)`、`delete_node(value)`、`find_node(value)`、`print_tree()`
- 编写一个演示脚本：随机生成输入集合，构建初始树并打印；逐次执行 add/delete 后打印；对 `find_node` 做正、负两种情况验证

## 数据结构设计
- `Node`：包含 `value`、`left`、`right` 字段；仅存储整数值，左右子指针可为空
- `BST`：包含 `root`(根节点) 与 `size`(元素数量)
- 命名约定：Python 使用 `snake_case`；代码内所有注释保持简短清晰英文

## 操作与算法
- 插入(`add_node`)：从根开始，按 BST 性质(左小右大)递归或迭代插入；遇到相同值不插入(保证集合唯一)
- 查找(`find_node`)：按 BST 性质从根向下查找；找到返回节点对象，未找到返回 `None`
- 删除(`delete_node`)：分三种情况处理
  - 叶子节点：直接删除
  - 仅有一个子节点：用该子节点替换被删节点
  - 有两个子节点：用“中序后继”(右子树的最小值)替换当前节点的值，再在右子树中删除该后继节点
- 打印(`print_tree`)：采用“侧向打印”(右→根→左)以层次感显示树结构；每一层增加固定缩进

## 演示流程
1. 随机生成输入集合：大小 `5` 至 `50`，取值范围 `1` 至 `1000`，使用无重复采样
2. 打印输入集合
3. 依次插入构建初始树，打印树
4. 执行若干次 `add_node` 与 `delete_node`，每次操作后立即打印树
5. `find_node` 的正例：从树中随机选一个已存在值查询；负例：随机选一个不在树中的值查询；打印是否找到

## 注意事项
- 重复值策略：为保持集合语义，遇到重复值忽略插入
- 空树打印：`print_tree()` 对空树需给出可读提示
- 递归深度：最大元素数为 50，递归实现安全；若需更大规模可改为迭代
- 删除不存在值：应安静返回，树结构不变
- 打印可读性：缩进宽度固定，保证层次清晰；控制输出标题与分隔线

## 运行与可复现
- 默认使用随机输入；如需可复现，可在代码中设置随机种子(可选)
- 运行方式将写入 `README.md`，建议直接执行 `python bst.py`

## 测试覆盖建议
- 插入：覆盖左插入、右插入、忽略重复
- 删除：分别覆盖叶子、单子节点、双子节点三类
- 查找：至少包含一个命中与一个未命中
- 打印：空树与非空树

## 代码注释规范
- 使用简短、明确的英文注释，例如：`# insert value into BST`、`# replace with inorder successor`
- 不写冗长段落，保持注释服务于理解关键步骤

## 题目2：摩斯电码元音序列计数——思路补充
- 问题：给定由 `.` 与 `-` 构成的长度 `n` 的串，统计仅由元音字母(A,E,I,O,U)组成的所有可能字母序列数量，其摩斯编码按字符连接后等于该串
- 采用国际摩斯编码：`A=.-`、`E=.`、`I=..`、`O=---`、`U=..-`
- 算法：动态规划
  - 设 `dp[i]` 表示前 `i` 个字符可被拆分为若干元音编码的方案数
  - 初值 `dp[0]=1`
  - 转移：对每个位置 `i` 和每个编码 `code`，若 `s[i:i+len(code)]==code`，则 `dp[i+len(code)] += dp[i]`
  - 答案为 `dp[n]`
- 复杂度：时间 `O(n*5)`，空间 `O(n)`；因仅 5 个元音编码，效率充足
- 注意：
  - 输入首行长度与实际串长不一致时，以实际串长为准进行计数
  - 仅允许使用元音编码，不考虑其他字母
  - 输出格式严格匹配要求的两行文本
